package nn.DenisAleksandrov;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Scanner;

public class Trainer {
    /**
     * The network to be trained
     */
    private final Network aNetwork;

    /**
     *
     * @param pNetwork network for this training instance
     */
    Trainer(Network pNetwork) {
        assert pNetwork != null;
        aNetwork = pNetwork;
    }

    /**
     * Trains aNetwork over descending number of iterations on given input and target values
     * For input and target we can give Trainer.getDataFromFile()[0] and Trainer.getDataFromFile()[0] respectively
     * To use data generated by the data harvester
     * @param input nxm matrix of input values
     * @param target nxw matrix of target values
     * @param eta initial learning rate
     * @param iterations initial iterations of training for each set of input and target arrays
     * @param reruns number of times to retrain, decreases iterations by half every time
     */
    public void train(double[][] input, double[][] target, double eta, int iterations, int reruns){
        for(int i = 0; i < reruns; i++){
            for(int trainSet = 0; trainSet < input.length; trainSet++){
                for(int trainNum = 0; trainNum < iterations; trainNum++){
                    /**
                     * NEED TO HAVE A DYNAMICALLY CHANGING ETA BASED ON THE MSE
                     */
                    aNetwork.train(input[trainSet], target[trainSet], eta);
                }
            }
            iterations = iterations / 2;
        }
    }

    /**
     * Gets distance sensor and corresponding target value data from a .csv file
     * @param pathname filepath for the .csv file
     * @return 3D int array. At the fist index you get the sensor input data by line in a 2D matrix
     * and the second index you get the target values by line in a 2D matrix
     * @throws IOException in the case that the file to read from cannot be found
     */
    public static double[][][] getDataFromFile(String pathname) throws IOException {
        File data = new File(pathname);
        Scanner scanner = new Scanner(data);
        int numOfLines = 0;
        while(scanner.hasNextLine()){
            scanner.nextLine();
            numOfLines++;
        }
        scanner.close();

        double[][][] trueOut = new double[2][numOfLines][];
        for(int i = 0; i < numOfLines; i++){
            trueOut[0][i] = new double[4];
            trueOut[1][i] = new double[12];
        }
        Scanner in = new Scanner(new File(pathname));
        int i = 0;
        while(in.hasNextLine()){
            String line = in.nextLine();
            double[] input = new double[4];
            double[] target = new double[12];
            // SOURCE: https://stackoverflow.com/questions/18838781/converting-string-array-to-an-integer-array
            int[] numbers = Arrays.stream(line.split(", ")).mapToInt(Integer::parseInt).toArray();
            for(int j = 0; j < 16; j++){
                if(j < 4){
                    input[j] = numbers[j];
                    continue;
                }
//                System.out.println(numOfLines);
//                System.out.println(j);
                target[j - 4] = numbers[j];
            }
            trueOut[0][i] = input;
            trueOut[1][i] = target;
            i++;
        }
        in.close();
        return trueOut;
    }

    /**
     * Tests network for OR operation. Index i = 0 holds confidence value for FALSE i = 1 holds value for TRUE in the
     * output layer of the network.
     *
     * Uncomment the saveNetwork line to avoid unnecessary re-training. Then use the static loadNetwork method
     * right under the saveNetwork line. Make sure to comment out all training and saving lines if you are loading
     * a network.
     */
    public static void ORTest(double[] testInput) throws IOException {
        double[][] orInput = new double[][]
                        {{0, 0},
                        {0, 1},
                        {1, 0},
                        {1, 1}};
        double[][] orTarget = new double[][]
                        {{1, 0},
                        {0, 1},
                        {0, 1},
                        {0, 1}};
        Network network = new Network(new int[]{2, 2, 2, 2});
        Trainer trainer = new Trainer(network);
        trainer.train(orInput, orTarget, 0.3, 100000, 100);
        //network.saveNetwork("OR_NETWORK.txt");
        //Network.loadNetwork("OR_NETWORK.txt");
        network.feedForward(testInput);
        for(int neuron = 0; neuron < network.OUTPUT_SIZE; neuron++){
            System.out.println(network.neurons[network.NETWORK_SIZE - 1][neuron].aOutput);
        }
    }

    public Network getaNetwork(){
        return aNetwork;
    }

    /**
     * Shows some ways to use this class.
     * Most of the training lines can be taken out, I left them here so you could see how to use this class.
     *
     * Right now each input value is mapped to three output values, this is not a good way to do it.
     * Ideally you need to have a one-to-one mapping between input and output values for training efficiency.
     * This is handled around lines 323 to 372 in the CGMoveALine class.
     *
     * Most of the work needs to be done in the Training class and maybe in the CGMoveALine class.
     * The Network class works well, one change that would be nice is to make the learning rate (eta)
     * change dynamically as the network is learning. I was thinking of doing this using the mean squared error (MSE),
     * but did not get to it.
     */
    public static void main(String[] args) throws IOException {
//        int[] ints = new int[]{4,2,4};
//        Trainer t = new Trainer(new Network(ints));
//        System.out.println(Trainer.getDataFromFile("test_output.txt")[1].length);
//        int[] layerSizes = new int[]{4, 6, 8, 10, 12};
//        Network network = new Network(layerSizes);
//        System.out.println(network.OUTPUT_SIZE);
//        Trainer trainer = new Trainer(network);
//        trainer.train(Trainer.getDataFromFile("towards_wall.txt")[0],
//                Trainer.getDataFromFile("towards_wall.txt")[1], 0.3, 100000, 10);
//        trainer.train(Trainer.getDataFromFile("towards_wall.txt")[0],
//                Trainer.getDataFromFile("away_from_wall.txt")[1], 0.3, 100000, 10);
//        trainer.train(Trainer.getDataFromFile("along_right_side.txt")[0],
//                Trainer.getDataFromFile("along_right_side.txt")[1], 0.3, 100000, 10);
//        trainer.train(Trainer.getDataFromFile("along_left_side.txt")[0],
//                Trainer.getDataFromFile("along_left_side.txt")[1], 0.3, 100000, 10);
        //network.saveNetwork("trained_network_test.txt");
        //Network network = Network.loadNetwork("trained_again_network_test.txt");
//        int[] layerSizes = new int[]{4, 6, 8, 10, 12};
//        Network network = new Network(layerSizes);
//        Trainer trainer = new Trainer(network);

//        trainer.train(Trainer.getDataFromFile("along_left_side.txt")[0],
//                Trainer.getDataFromFile("along_left_side.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("towards_wall.txt")[0],
//                Trainer.getDataFromFile("towards_wall.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("along_right_side.txt")[0],
//                Trainer.getDataFromFile("along_right_side.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("away_from_wall.txt")[0],
//                Trainer.getDataFromFile("away_from_wall.txt")[1], 0.3, 100000, 10);
//
//        /////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//        trainer.train(Trainer.getDataFromFile("towards_wall.txt")[0],
//                Trainer.getDataFromFile("towards_wall.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("along_left_side.txt")[0],
//                Trainer.getDataFromFile("along_left_side.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("away_from_wall.txt")[0],
//                Trainer.getDataFromFile("away_from_wall.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("along_right_side.txt")[0],
//                Trainer.getDataFromFile("along_right_side.txt")[1], 0.3, 100000, 10);
//
//        //////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//        trainer.train(Trainer.getDataFromFile("away_from_wall.txt")[0],
//                Trainer.getDataFromFile("away_from_wall.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("along_right_side.txt")[0],
//                Trainer.getDataFromFile("along_right_side.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("along_left_side.txt")[0],
//                Trainer.getDataFromFile("along_left_side.txt")[1], 0.3, 100000, 10);
//
//        trainer.train(Trainer.getDataFromFile("towards_wall.txt")[0],
//                Trainer.getDataFromFile("towards_wall.txt")[1], 0.3, 100000, 10);

        //Network network = Network.loadNetwork("trained_network_test.txt");
        //Network network = new Network(new int[]{});
        //network.saveNetwork("trained_network_test.txt");
//        String[] messages = network.getMessage(0.7);
//        for(String message: messages){
//            System.out.println(message);
//        }
        //for(Network.Neuron neuron: network.neurons[network.NETWORK_SIZE - 1][network.OUTPUT_SIZE - 1])
//        for(int neuron = 0; neuron < network.OUTPUT_SIZE; neuron++){
//            System.out.println(network.neurons[network.NETWORK_SIZE - 1][neuron].aOutput);
//        }
        Trainer.ORTest(new double[]{0, 0});
    }
}
